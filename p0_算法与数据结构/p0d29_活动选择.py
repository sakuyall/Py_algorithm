"""11/16/25
活动选择
    假设有n个活动,需要使用同一片场地,但同一时间只能进行一个活动
    每个活动开始时间s结束时间f,如何安排使举办活动数量最多
    i  1 2 3 4 5 6  7  8  9  10 11
    s  1 3 0 5 3 5  6  8  8  2  12
    f  4 5 6 7 9 9 10 11 12  14 16

贪心:优先选择最早结束的活动,为后期留更多时间,结论:最先结束的活动一定是最优解的一部分
"""
activities = [(1, 4), (3, 5), (0, 6), (5, 7), (3, 9), (5, 9), (6, 10), (8, 11), (8, 12), (2, 14), (12, 16)]
# 每次贪心最早结束的活动,先对活动进行排序
activities.sort(key=lambda x:x[1])

def activity_selection(a):
    res = [a[0]]   # 每次看活动列表中最靠前(结束早)的活动
    for i in range(1, len(a)):
        # 0已被取出,从1开始寻找不与0冲突的活动
        if a[i][0] >= res[-1][1]:
            # 若下一个活动开始时间小于等于上一个活动结束时间则不冲突
            res.append(a[i])      # 就把它加到计划res中
    return res
    
print(activity_selection(activities))
# 返回[(1, 4), (5, 7), (8, 11), (12, 16)]

"""
总结
    问题在于看出题目是否是贪心,以及贪心要贪什么
    对于以上四个问题而言,都是属于最优化问题,一般贪心局部最优解即为问题最优解
    思路简单,代码好写,运行快
"""